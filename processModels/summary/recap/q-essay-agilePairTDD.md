<panel header="{{ icon_Q_A }} Agile processes, Pair programming, Test-driven development">

Find out more about the following three topics and give at least three arguments for and three arguments against each.

(a) Agile processes

(b) Pair programming

(c) Test-driven development

<panel type="seamless" header="{{ icon_A }} Answer" minimized>

(a) Arguments in favor of agile processes:

* More focus on customer satisfaction.
* Less chance of building the wrong product (because of frequent customer feedback).
* Less resources wasted on bureaucracy, over-documenting, contract negotiations.

Arguments against agile processes (not necessarily true):

* It is ‘just hacking’. Not very systematic. No discipline.
* It is hard to know in advance the exact final product.
* It does not give enough attention to documentation.
* Lack of management control (too much freedom given to developers).

(b) Arguments in favor of pair programming:

* It could produce better quality code.
* It is good to have more than one person know about any piece of code.
* It is a way to learn from each other.
* It can be used to train new programmers.
* Better discipline and better time management (e.g. less likely to play Farmville while working).
* Better morale due to more interactions with co-workers.

Arguments against pair programming:

* Increases the total man-hours required.
* Personality clashes between pair-members.
* Workspaces need to be adapted to suit two developers working at one computer.
* If pairs are rotated, one needs to know more parts of the system than in solo programming.

(c) Arguments in favor of TDD:

* Testing will not be neglected due to time pressure (because it is done first).
* Forces the developer to think about how exactly the component should behave, before jumping into implementing it.
* Avoids wasting programmer effort (i.e., the code ends up doing exactly what's needed; no less, no more).
* Forces the programmer to automate all tests.

Arguments against TDD (not necessarily true):

* Since tests can be seen as ‘executable specifications’, programmers tend to neglect other forms of documentation.
* Promotes ‘trial-and-error’ coding instead of making programmers think through their algorithms (i.e., ‘just keep hacking until all tests pass’).
* Gives a false sense of security. (What if you forgot to test certain scenarios?)
* Not intuitive. Some programmers might resist adopting TDD.

</panel>
</panel>
