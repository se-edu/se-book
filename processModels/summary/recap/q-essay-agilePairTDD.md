<panel header="{{ icon_Q_A }} Agile processes, Pair programming, Test-driven development">
<question has-input="true">

Find out more about the following three topics and give at least three arguments for and three arguments against each.

(a) Agile processes

(b) Pair programming

(c) Test-driven development

<div slot="answer">

(a) Arguments in favor of agile processes:

* More focus on customer satisfaction.
* Less chance of building the wrong product (because of frequent customer feedback).
* Less resource wasted on bureaucracy, over-documenting, contract negotiations.

Arguments against agile processes (not necessarily true):

* It is ‘just hacking’. Not very systematic. No discipline.
* It is hard to know in advance the exact final product.
* It does not give enough attention to documentation.
* Lack of management control (gives too much freedom to developers)

(b) Arguments in favor of pair programming:

* It could produce better quality code.
* It is good to have more than one person know about any piece of code.
* It is a way to learn from each other.
* It can be used to train new programmers.
* Better discipline and better time management (e.g. less likely to play Farmville while working).
* Better morale due to more interactions with co-workers.

Arguments against pair programming:

* Increase in total man hours required
* Personality clashes between pair-members
* Workspaces need to be adapted to suit two developers working at one computer.
* If pairs are rotated, one needs to know more parts of the system than in solo programming

(c) Arguments in favor of TDD:

* Testing will not be neglected due to time pressure (because it is done first).
* Forces the developer to think about what the component should be before jumping into implementing it.
* Optimizes programmer effort (i.e. if all tests pass, there is no need to add any more functionality).
* Forces us to automate all tests.

Arguments against TDD (not necessarily true):

* Since tests can be seen as ‘executable specifications’, programmers tend to neglect others forms of documentation.
* Promotes ‘trial-and-error’ coding instead of making programmers think through their algorithms (i.e. ‘just keep hacking until all tests pass’).
* Gives a false sense of security. (what if you forgot to test certain scenarios?)

Not intuitive. Some programmer might resist adopting TDD.

</div>
</question>
</panel>
