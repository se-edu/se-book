<div></div>
<p></p>
<p><span class="dimmed"><strong><span>Principles →</span></strong></span></p>
<div id="title-and-body">
  <div>
    <h4 id="solid-principles"><span>SOLID principles</span><a class="fa fa-anchor" href="#solid-principles" onclick="event.stopPropagation()"></a></h4>
  </div>
  <div id="main">
    <div>
      <p>The five OOP principles given below are known as <em>SOLID Principles</em> (an acronym made up of the first letter of each principle):</p>
      <panel type="seamless" class="algolia-no-index"><template slot="_header">
          <p><strong>S</strong>ingle Responsibility Principle (SRP)</p>
        </template>
        <div>
          <div></div>
          <p></p>
          <p><span class="dimmed"><strong><span>Principles →</span></strong></span></p>
          <div id="title-and-body">
            <div>
              <h4 id="single-responsibility-principle"><span>Single responsibility principle</span><a class="fa fa-anchor" href="#single-responsibility-principle" onclick="event.stopPropagation()"></a></h4>
            </div>
            <div id="main">
              <div>
                <box type="definition" seamless>
                  <div>
                    <p><strong>Single responsibility principle (SRP)</strong>: A class should have one, and only one, reason to change. <sub>-- Robert C. Martin</sub></p>
                  </div>
                </box>
                <p>If a class has only one responsibility, it needs to change only when there is a change to that responsibility.</p>
                <box>
                  <p><span><span aria-hidden="true" class="fas fa-cube"></span></span> Consider a <code v-pre>TextUi</code> class that does parsing of the user commands as well as interacting with the user. That class needs to change when the formatting of the UI changes as well as when the syntax of the user command changes. Hence, such a class does not follow the SRP.</p>
                </box>
                <blockquote>
                  <p><span aria-hidden="true" class="fas fa-quote-left"></span> Gather together the things that change for the same reasons. Separate those things that change for different reasons. <sub>―<em>Agile Software Development, Principles, Patterns, and Practices</em> by Robert C. Martin</sub></p>
                </blockquote>
              </div>
              <div>
                <div>
                  <panel expanded><template slot="_header">
                      <p><span><span aria-hidden="true" class="fas fa-paperclip"></span></span> Resources</p>
                    </template>
                    <ul>
                      <li><a href="http://www.oodesign.com/single-responsibility-principle.html">An explanation of the SRP</a> from <a href="http://www.oodesign.com">www.oodesign.com</a></li>
                      <li><a href="http://code.tutsplus.com/tutorials/solid-part-1-the-single-responsibility-principle--net-36074">Another explanation (more detailed)</a>
                        by Patkos Csaba</li>
                      <li><a href="https://drive.google.com/file/d/0ByOwmqah_nuGNHEtcU5OekdDMkk/view">A book chapter on SRP</a> - A book chapter on SRP, written by the father of the principle itself Robert C Martin.</li>
                    </ul>
                  </panel>
                </div>
              </div>
            </div>
          </div>
        </div>
      </panel>
      <panel type="seamless" class="algolia-no-index"><template slot="_header">
          <p><strong>O</strong>pen-Closed Principle (OCP)</p>
        </template>
        <div>
          <div></div>
          <p></p>
          <p><span class="dimmed"><strong><span>Principles →</span></strong></span></p>
          <div id="title-and-body">
            <div>
              <h4 id="open-closed-principle"><span>Open-closed principle</span><a class="fa fa-anchor" href="#open-closed-principle" onclick="event.stopPropagation()"></a></h4>
            </div>
            <div id="main">
              <div>
                <p><strong>The Open-Close Principle aims to make a code entity easy to adapt and reuse without needing to modify the code entity itself.</strong></p>
                <box type="definition" seamless>
                  <div>
                    <p><strong>Open-closed principle (OCP)</strong>: A module should be <em>open</em> for extension but <em>closed</em> for modification. That is, modules should be written so that they can be extended, without requiring them to be modified. <sub>-- proposed by <a href="https://en.wikipedia.org/wiki/Bertrand_Meyer">Bertrand Meyer</a></sub></p>
                  </div>
                </box>
                <p>In object-oriented programming, OCP can be achieved in various ways. This often requires separating the <em>specification (i.e. interface)</em> of a module from its <em>implementation</em>.</p>
                <box>
                  <p><span><span aria-hidden="true" class="fas fa-cube"></span></span> In the design given below, the behavior of the <code v-pre>CommandQueue</code> class can be altered by adding more concrete <code v-pre>Command</code> subclasses. For example, by including a <code v-pre>Delete</code> class alongside <code v-pre>List</code>, <code v-pre>Sort</code>, and <code v-pre>Reset</code>, the <code v-pre>CommandQueue</code> can now perform delete commands without modifying its code at all. That is, its behavior was extended without having to modify its code. Hence, it was open to extensions, but closed to modification.</p>
                  <img src="/se-book/principles/openClosedPrinciple/images/commandQueue.png" height="170">
                  <p></p>
                </box>
                <box>
                  <p><span><span aria-hidden="true" class="fas fa-cube"></span></span> The behavior of a Java generic class can be altered by passing it a different class as a parameter. In the code below, the <code v-pre>ArrayList</code> class behaves as a container of <code v-pre>Students</code> in one instance and as a container of <code v-pre>Admin</code> objects in the other instance, without having to change its code. That is, the behavior of the <code v-pre>ArrayList</code> class is extended without modifying its code.</p>
                  <pre><code class="hljs java" v-pre><span>ArrayList students = <span class="hljs-keyword">new</span> ArrayList&lt;Student&gt;();<br></span><span>ArrayList admins = <span class="hljs-keyword">new</span> ArrayList&lt;Admin&gt;();<br></span></code></pre>
                </box>
              </div>
              <div>
                <div>
                  <panel expandable class="algolia-no-index"><template slot="_header">
                      <p><span><span aria-hidden="true" class="fas fa-dumbbell"></span></span> Exercises</p>
                    </template>
                    <div>
                      <panel class="algolia-no-index"><template slot="_header">
                          <p><span><span aria-hidden="true" class="glyphicon glyphicon-question-sign"></span></span><span aria-hidden="true" class="glyphicon glyphicon-ok-sign"></span> Meaning of OCP</p>
                        </template>
                        <question>
                          <p>Which of these is closest to the meaning of the open-closed principle?</p>
                          <ul radio-group="6906e" class="radio-list">
                            <li class="radio-list-item"><label><input class="radio-list-input" name="6906e" type="radio"> a. We should be able to change a software module’s behavior without modifying its code.</label></li>
                            <li class="radio-list-item"><label><input class="radio-list-input" name="6906e" type="radio"> b. A software module should remain open to modification as long as possible.</label></li>
                            <li class="radio-list-item"><label><input class="radio-list-input" name="6906e" type="radio"> c. A software module should be open to modification and closed to extension.</label></li>
                            <li class="radio-list-item"><label><input class="radio-list-input" name="6906e" type="radio"> d. Open source software rocks. Closed source software sucks.</label></li>
                          </ul>
                          <div slot="answer" class="algolia-no-index">
                            <p>(a)</p>
                            <p>Explanation: Please refer the handout for the definition of OCP.</p>
                          </div>
                        </question>
                      </panel>
                    </div>
                  </panel>
                </div>
              </div>
            </div>
          </div>
        </div>
      </panel>
      <panel type="seamless" class="algolia-no-index"><template slot="_header">
          <p><strong>L</strong>iskov Substitution Principle (LSP)</p>
        </template>
        <div>
          <div></div>
          <p></p>
          <p><span class="dimmed"><strong><span>Principles →</span></strong></span></p>
          <div id="title-and-body">
            <div>
              <h4 id="liskov-substitution-principle"><span>Liskov substitution principle</span><a class="fa fa-anchor" href="#liskov-substitution-principle" onclick="event.stopPropagation()"></a></h4>
            </div>
            <div id="main">
              <div>
                <box type="definition" seamless>
                  <div>
                    <p><strong>Liskov substitution principle (LSP)</strong>: Derived classes must be substitutable for their base classes. <sub>-- proposed by <a href="https://en.wikipedia.org/wiki/Barbara_Liskov">Barbara Liskov</a></sub></p>
                  </div>
                </box>
                <p>LSP sounds same as <span large trigger="click" for="modal:lsp-substitutability" v-b-popover.click.top.html="popoverGenerator" v-b-tooltip.click.top.html="tooltipContentGetter" v-on:click="$refs['modal:lsp-substitutability'].show()" class="trigger-click">substitutability</span> but it goes beyond substitutability; <strong>LSP implies that a subclass should not be more restrictive than the behavior specified by the superclass.</strong> As you know, Java has language support for substitutability. However, if LSP is not followed, substituting a subclass object for a superclass object can break the functionality of the code.</p>
                <b-modal id="modal:lsp-substitutability" hide-footer size="lg" modal-class="mb-zoom" ref="modal:lsp-substitutability" class="algolia-no-index"><template slot="modal-title">Textbook <span><span aria-hidden="true" class="glyphicon glyphicon-log-in"></span></span></template>
                  <div>
                    <div>
                      <p>
                        <panel src="/se-book/oop/inheritance/what/unit-inElsewhere-asFlat._include_.html" popup-url="/se-book/oop/inheritance/what" class="algolia-no-index"><template slot="_header">
                            <p><span class="dimmed"><span><span aria-hidden="true" class="glyphicon glyphicon-education"></span></span> Paradigms → Object Oriented Programming → Inheritance → What</span></p>
                          </template></panel>
                      </p>
                    </div>
                    <p></p>
                    <p><span class="dimmed"><strong><span>Paradigms → OOP → Inheritance →
                          </span></strong></span></p>
                    <div id="title-and-body">
                      <div>
                        <h4 id="substitutability"><span>Substitutability</span><a class="fa fa-anchor" href="#substitutability" onclick="event.stopPropagation()"></a></h4>
                      </div>
                      <div id="main">
                        <div>
                          <p><strong>Every instance of a subclass is an instance of the superclass, but not vice-versa.</strong> As a result, inheritance allows <em>substitutability</em> : the ability to substitute a child class object where a parent class object is expected.</p>
                          <box>
                            <img src="/se-book/oop/inheritance/substitutability/images/staff.png" height="80">
                            <p></p>
                            <p><span><span aria-hidden="true" class="fas fa-cube"></span></span> an <code v-pre>Academic</code> is an instance of a <code v-pre>Staff</code>, but a <code v-pre>Staff</code> is not necessarily an instance of an <code v-pre>Academic</code>. i.e. wherever an object of the superclass is expected, it can be substituted by an object of any of its subclasses.</p>
                            <p>The following code is valid because an <code v-pre>AcademicStaff</code> object is substitutable as a <code v-pre>Staff</code> object.</p>
                            <pre><code class="hljs java" v-pre><span>Staff staff = <span class="hljs-keyword">new</span> AcademicStaff (); <span class="hljs-comment">// OK</span><br></span></code></pre>
                            <p>But the following code is not valid <span class="dimmed">because <code v-pre>staff</code> is declared as a <code v-pre>Staff</code> type and therefore its value may or may not be of type <code v-pre>AcademicStaff</code>, which is the type expected by variable <code v-pre>academicStaff</code>.</span></p>
                            <pre><code class="hljs java" v-pre><span>Staff staff;<br></span><span>...<br></span><span>AcademicStaff academicStaff = staff; <span class="hljs-comment">// Not OK</span><br></span></code></pre>
                          </box>
                        </div>
                        <div></div>
                      </div>
                    </div>
                  </div>
                </b-modal>
                <box>
                  <p><span><span aria-hidden="true" class="fas fa-cube"></span></span> Suppose the <code v-pre>Payroll</code> class depends on the <code v-pre>adjustMySalary(int percent)</code> method of the <code v-pre>Staff</code> class. Furthermore, the <code v-pre>Staff</code> class states that the <code v-pre>adjustMySalary</code> method will work for all positive percent values. Both <code v-pre>Admin</code> and <code v-pre>Academic</code> classes override the <code v-pre>adjustMySalary</code> method.</p>
                  <img src="/se-book/principles/liskovSubstitutionPrinciple/images/payroll.png" height="200">
                  <p></p>
                  <p>Now consider the following:</p>
                  <ul>
                    <li><code v-pre>Admin#adjustMySalary</code> method works for both negative and positive percent values.</li>
                    <li><code v-pre>Academic#adjustMySalary</code> method works for percent values <code v-pre>1..100</code> only.</li>
                  </ul>
                  <p>In the above scenario,</p>
                  <ul>
                    <li><code v-pre>Admin</code> class follows LSP because it fulfills <code v-pre>Payroll</code>’s expectation of <code v-pre>Staff</code> objects (i.e. it works for all positive values). Substituting <code v-pre>Admin</code> objects for Staff objects will not break the <code v-pre>Payroll</code> class functionality.</li>
                    <li><code v-pre>Academic</code> class violates LSP because it will not work for percent values over <code v-pre>100</code> as expected by the <code v-pre>Payroll</code> class. Substituting <code v-pre>Academic</code> objects for <code v-pre>Staff</code> objects can potentially break the <code v-pre>Payroll</code> class functionality.</li>
                  </ul>
                  <panel type="seamless" class="algolia-no-index"><template slot="_header">
                      <p><span class="dimmed">Another example</span></p>
                    </template>
                    <p><span><span aria-hidden="true" class="fas fa-cube"></span></span> The <code v-pre>Rectangle#resize()</code> can take any integers for <code v-pre>height</code> and <code v-pre>width</code>. This contract is violated by the subclass <code v-pre>Square#resize()</code> because it does not accept a <code v-pre>height</code> that is different from the <code v-pre>width</code>.</p>
                    <img src="/se-book/principles/liskovSubstitutionPrinciple/images/rectangleSquare.png" height="120">
                    <p></p>
                    <pre><code class="hljs java" v-pre><span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> </span>{<br></span><span>    ...<br></span><span>    <span class="hljs-comment">/** sets the size to given height and width*/</span><br></span><span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> height, <span class="hljs-keyword">int</span> width)</span></span>{<br></span><span>        ...<br></span><span>    }<br></span><span>}<br></span><span><br></span><span><br></span><span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Rectangle</span> </span>{<br></span><span>    <br></span><span>    <span class="hljs-meta">@Override</span><br></span><span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> height, <span class="hljs-keyword">int</span> width)</span></span>{<br></span><span>        <span class="hljs-keyword">if</span> (height != width) {<br></span><span>            <span class="hljs-comment">//error</span><br></span><span>       }<br></span><span>    }<br></span><span>}<br></span></code></pre>
                    <p>Now consider the following method that is written to work with the <code v-pre>Rectangle</code> class.</p>
                    <pre><code class="hljs java" v-pre><span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">makeSameSize</span><span class="hljs-params">(Rectangle original, Rectangle toResize)</span></span>{<br></span><span>    toResize.resize(original.getHeight(), original.getWidth());<br></span><span>}<br></span></code></pre>
                    <p>This code will fail if it is called as <code v-pre>maekSameSize(new Rectangle(12,8), new Square(4, 4))</code> That is, <code v-pre>Square</code> class is not substitutable for the <code v-pre>Rectangle</code> class.</p>
                  </panel>
                </box>
              </div>
              <div>
                <div>
                  <panel expandable class="algolia-no-index"><template slot="_header">
                      <p><span><span aria-hidden="true" class="fas fa-dumbbell"></span></span> Exercises</p>
                    </template>
                    <div>
                      <panel class="algolia-no-index"><template slot="_header">
                          <p><span><span aria-hidden="true" class="glyphicon glyphicon-question-sign"></span></span><span aria-hidden="true" class="glyphicon glyphicon-ok-sign"></span> Is this LSP?</p>
                        </template>
                        <question>
                          <p>If a subclass imposes more restrictive conditions than its parent class, it violates Liskov Substitution Principle.</p>
                          <ul radio-group="55ada" class="radio-list">
                            <li class="radio-list-item"><label><input class="radio-list-input" name="55ada" type="radio"> True</label></li>
                            <li class="radio-list-item"><label><input class="radio-list-input" name="55ada" type="radio"> False</label></li>
                          </ul>
                          <div slot="answer" class="algolia-no-index">
                            <p>True.</p>
                            <p>Explanation: If the subclass is more restrictive than the parent class, code that worked with the parent class may not work with the child class. Hence, the substitutability does not exist and LSP has been violated.</p>
                          </div>
                        </question>
                      </panel>
                    </div>
                  </panel>
                </div>
              </div>
            </div>
          </div>
        </div>
      </panel>
      <panel type="seamless" class="algolia-no-index"><template slot="_header">
          <p><strong>I</strong>nterface Segregation Principle (ISP)</p>
        </template>
        <div>
          <div></div>
          <p></p>
          <p><span class="dimmed"><strong><span>Principles →</span></strong></span></p>
          <div id="title-and-body">
            <div>
              <h4 id="interface-segregation-principle"><span>Interface segregation principle</span><a class="fa fa-anchor" href="#interface-segregation-principle" onclick="event.stopPropagation()"></a></h4>
            </div>
            <div id="main">
              <div>
                <box type="definition" seamless>
                  <div>
                    <p><strong>Interface segregation principle (ISP)</strong>: No client should be forced to depend on methods it does not use.</p>
                  </div>
                </box>
                <box>
                  <p><span><span aria-hidden="true" class="fas fa-cube"></span></span> The <code v-pre>Payroll</code> class should not depend on the <code v-pre>AdminStaff</code> class because it does not use the <code v-pre>arrangeMeeting()</code> method. Instead, it should depend on the <code v-pre>SalariedStaff</code> interface.</p>
                  <pre><code class="hljs java" v-pre><span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Payroll</span> </span>{<br></span><span>    <span class="hljs-comment">//...    </span><br></span><span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">adjustSalaries</span><span class="hljs-params">(AdminStaff adminStaff)</span></span>{ <span class="hljs-comment">//violates ISP</span><br></span><span>        <span class="hljs-comment">//...</span><br></span><span>    }<br></span><span><br></span><span>}<br></span></code></pre>
                  <pre><code class="hljs java" v-pre><span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Payroll</span> </span>{<br></span><span>    <span class="hljs-comment">//...    </span><br></span><span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">adjustSalaries</span><span class="hljs-params">(SalariedStaff staff)</span></span>{ <span class="hljs-comment">//does not violate ISP</span><br></span><span>        <span class="hljs-comment">//...</span><br></span><span>    }<br></span><span>}<br></span></code></pre><img src="/se-book/principles/interfaceSegregationPrinciple/images/payroll.png" height="200">
                  <p></p>
                </box>
              </div>
              <div></div>
            </div>
          </div>
        </div>
      </panel>
      <panel type="seamless" class="algolia-no-index"><template slot="_header">
          <p><strong>D</strong>ependency Inversion Principle (DIP)</p>
        </template>
        <div>
          <div></div>
          <p></p>
          <p><span class="dimmed"><strong><span>Principles →</span></strong></span></p>
          <div id="title-and-body">
            <div>
              <h4 id="dependency-inversion-principle"><span>Dependency inversion principle</span><a class="fa fa-anchor" href="#dependency-inversion-principle" onclick="event.stopPropagation()"></a></h4>
            </div>
            <div id="main">
              <div>
                <box type="definition" seamless>
                  <div>
                    <p><strong>Dependency inversion principle</strong>:</p>
                    <ol>
                      <li>High-level modules should not depend on low-level modules. Both should depend on abstractions.</li>
                      <li>Abstractions should not depend on details. Details should depend on abstractions.</li>
                    </ol>
                  </div>
                </box>
                <box>
                  <p>Example:</p>
                  <img src="/se-book/principles/dependencyInversionPrinciple/images/payrollEmployee.png" height="130">
                  <p></p>
                  <p>In design (a), the higher level class <code v-pre>Payroll</code> depends on the lower level class <code v-pre>Employee</code>, a violation of DIP. In design (b), both <code v-pre>Payroll</code> and <code v-pre>Employee</code> depends on the Payee interface (note that inheritance is a dependency).</p>
                  <p>Design (b) is more flexible (and less coupled) because now the <code v-pre>Payroll</code> class need not change when the <code v-pre>Employee</code> class changes.</p>
                </box>
              </div>
              <div>
                <div>
                  <panel expandable class="algolia-no-index"><template slot="_header">
                      <p><span><span aria-hidden="true" class="fas fa-dumbbell"></span></span> Exercises</p>
                    </template>
                    <div>
                      <panel class="algolia-no-index"><template slot="_header">
                          <p><span><span aria-hidden="true" class="glyphicon glyphicon-question-sign"></span></span><span aria-hidden="true" class="glyphicon glyphicon-ok-sign"></span> Which of these statements is true about the Dependency Inversion Principle.</p>
                        </template>
                        <question>
                          <p>Which of these statements is true about the Dependency Inversion Principle.</p>
                          <ul class="contains-task-list">
                            <li class="task-list-item enabled"><input class="task-list-item-checkbox" type="checkbox"> a. It can complicate the design/implementation by introducing extra abstractions, but it has some benefits.</li>
                            <li class="task-list-item enabled"><input class="task-list-item-checkbox" type="checkbox"> b. It is often used during testing, to replace dependencies with mocks.</li>
                            <li class="task-list-item enabled"><input class="task-list-item-checkbox" type="checkbox"> c. It reduces dependencies in a design.</li>
                            <li class="task-list-item enabled"><input class="task-list-item-checkbox" type="checkbox"> d. It advocates making higher level classes to depend on lower level classes.</li>
                          </ul>
                          <div slot="answer" class="algolia-no-index">
                            <p>a</p>
                            <p>Explanation: Replacing dependencies with mocks is Dependency Injection, not DIP. DIP does not reduce dependencies, rather, it changes the direction of dependencies. Yes, it can introduce extra abstractions but often the benefit can outweigh the extra complications.</p>
                          </div>
                        </question>
                      </panel>
                    </div>
                  </panel>
                </div>
              </div>
            </div>
          </div>
        </div>
      </panel>
    </div>
    <div></div>
  </div>
</div>