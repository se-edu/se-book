<div></div><p></p>
<p><span class="dimmed"><strong><span>Principles →</span></strong></span></p>
<div id="title-and-body">
<div><h4 id="solid-principles"><span id="solid-principles" class="anchor"></span><span>SOLID principles</span><a class="fa fa-anchor" href="#solid-principles" onclick="event.stopPropagation()"></a></h4></div>
<div id="main">
<div>
<p>The five OOP principles given below are known as <em>SOLID Principles</em> (an acronym made up of the first letter of each principle):</p>
<panel type="seamless"><template #header><p><strong>S</strong>ingle Responsibility Principle (SRP)</p></template>
  <div><div></div><p></p>
<p><span class="dimmed"><strong><span>Principles →</span></strong></span></p>
<div id="title-and-body">
<div><h4 id="single-responsibility-principle"><span id="single-responsibility-principle" class="anchor"></span><span>Single responsibility principle</span><a class="fa fa-anchor" href="#single-responsibility-principle" onclick="event.stopPropagation()"></a></h4></div>
<div id="main">
<div>
<box type="definition" seamless>
<div><p><strong>Single responsibility principle (SRP)</strong>: A class should have one, and only one, reason to change. <sub>-- Robert C. Martin</sub></p></div></box>
<p>If a class has only one responsibility, it needs to change only when there is a change to that responsibility.</p>
<box>
<p><span><span aria-hidden="true" class="fas fa-cube"></span></span> Consider a <code class="hljs inline no-lang" v-pre>TextUi</code> class that does parsing of the user commands as well as interacting with the user. That class needs to change when the formatting of the UI changes as well as when the syntax of the user command changes. Hence, such a class does not follow the SRP.</p></box>
<blockquote>
<p><span aria-hidden="true" class="fas fa-quote-left"></span> Gather together the things that change for the same reasons. Separate those things that change for different reasons. <span aria-hidden="true" class="fas fa-quote-right"></span> <sub>―- <em>Agile Software Development, Principles, Patterns, and Practices</em> by Robert C. Martin</sub></p></blockquote></div>
<div>
<div><panel expanded><template #header><p><span><span aria-hidden="true" class="fas fa-paperclip"></span></span>  Resources</p></template>
<ul>
<li><a href="http://www.oodesign.com/single-responsibility-principle.html">An explanation of the SRP</a> from www.oodesign.com</li>
<li><a href="http://code.tutsplus.com/tutorials/solid-part-1-the-single-responsibility-principle--net-36074">Another explanation (more detailed)</a>
by Patkos Csaba</li>
<li><a href="https://drive.google.com/file/d/0ByOwmqah_nuGNHEtcU5OekdDMkk/view">A book chapter on SRP</a> written by the father of the principle itself, Robert C Martin</li></ul></panel></div></div></div></div></div></panel>
<panel type="seamless"><template #header><p><strong>O</strong>pen-Closed Principle (OCP)</p></template>
  <div><div></div><p></p>
<p><span class="dimmed"><strong><span>Principles →</span></strong></span></p>
<div id="title-and-body">
<div><h4 id="open-closed-principle"><span id="open-closed-principle" class="anchor"></span><span>Open-closed principle</span><a class="fa fa-anchor" href="#open-closed-principle" onclick="event.stopPropagation()"></a></h4></div>
<div id="main">
<div>
<p><strong>The Open-Closed Principle aims to make a code entity easy to adapt and reuse without needing to modify the code entity itself.</strong></p>
<box type="definition" seamless>
<div><p><strong>Open-closed principle (OCP)</strong>: A module should be <em>open</em> for extension but <em>closed</em> for modification. That is, modules should be written so that they can be extended, without requiring them to be modified. <sub>-- proposed by <a href="https://en.wikipedia.org/wiki/Bertrand_Meyer">Bertrand Meyer</a></sub></p></div></box>
<p>In object-oriented programming, OCP can be achieved in various ways. This often requires separating the <em>specification (i.e. interface)</em> of a module from its <em>implementation</em>.</p>
<box>
<p><span><span aria-hidden="true" class="fas fa-cube"></span></span> In the design given below, the behavior of the <code class="hljs inline no-lang" v-pre>CommandQueue</code> class can be altered by adding more concrete <code class="hljs inline no-lang" v-pre>Command</code> subclasses. For example, by including a <code class="hljs inline no-lang" v-pre>Delete</code> class alongside <code class="hljs inline no-lang" v-pre>List</code>, <code class="hljs inline no-lang" v-pre>Sort</code>, and <code class="hljs inline no-lang" v-pre>Reset</code>, the <code class="hljs inline no-lang" v-pre>CommandQueue</code> can now perform delete commands without modifying its code at all. That is, its behavior was extended without having to modify its code. Hence, it is open to extensions, but closed to modification.</p>
<pic src="/se-book/principles/openClosedPrinciple/images/commandQueue.png" height="170"></pic>
<p></p></box>
<box>
<p><span><span aria-hidden="true" class="fas fa-cube"></span></span> The behavior of a Java generic class can be altered by passing it a different class as a parameter. In the code below, the <code class="hljs inline no-lang" v-pre>ArrayList</code> class behaves as a container of <code class="hljs inline no-lang" v-pre>Students</code> in one instance and as a container of <code class="hljs inline no-lang" v-pre>Admin</code> objects in the other instance, without having to change its code. That is, the behavior of the <code class="hljs inline no-lang" v-pre>ArrayList</code> class is extended without modifying its code.</p>
<pre><code class="hljs java" v-pre><span>ArrayList students = <span class="hljs-keyword">new</span> ArrayList&lt;Student&gt;();
</span><span>ArrayList admins = <span class="hljs-keyword">new</span> ArrayList&lt;Admin&gt;();
</span></code></pre></box></div>
<div>
<div><panel expandable><template #header><p><span><span aria-hidden="true" class="fas fa-dumbbell"></span></span> Exercises</p></template>
  <div><panel><template #header><p><span><span aria-hidden="true" class="glyphicon glyphicon-question-sign"></span></span><span><span aria-hidden="true" class="glyphicon glyphicon-ok-sign"></span></span> Meaning of OCP</p></template>
<question>
<p>Which of these is closest to the meaning of the open-closed principle?</p>
<ul radio-group="6906e" class="radio-list">
<li class="radio-list-item"><label><input class="radio-list-input" name="6906e" type="radio"> a. We should be able to change a software module’s behavior without modifying its code.</label></li>
<li class="radio-list-item"><label><input class="radio-list-input" name="6906e" type="radio"> b. A software module should remain open to modification as long as possible.</label></li>
<li class="radio-list-item"><label><input class="radio-list-input" name="6906e" type="radio"> c. A software module should be open to modification and closed to extension.</label></li>
<li class="radio-list-item"><label><input class="radio-list-input" name="6906e" type="radio"> d. Open source software rocks. Closed source software sucks.</label></li></ul>
<template #answer><div>
<p>(a)</p>
<p>Explanation: Please refer the handout for the definition of OCP.</p></div></template></question></panel></div></panel></div></div></div></div></div></panel>
<panel type="seamless"><template #header><p><strong>L</strong>iskov Substitution Principle (LSP)</p></template>
  <div><div></div><p></p>
<p><span class="dimmed"><strong><span>Principles →</span></strong></span></p>
<div id="title-and-body">
<div><h4 id="liskov-substitution-principle"><span id="liskov-substitution-principle" class="anchor"></span><span>Liskov substitution principle</span><a class="fa fa-anchor" href="#liskov-substitution-principle" onclick="event.stopPropagation()"></a></h4></div>
<div id="main">
<div>
<box type="definition" seamless>
<div><p><strong>Liskov substitution principle (LSP)</strong>: Derived classes must be substitutable for their base classes. <sub>-- proposed by <a href="https://en.wikipedia.org/wiki/Barbara_Liskov">Barbara Liskov</a></sub></p></div></box>
<p>LSP sounds the same as <trigger large trigger="click" for="modal:lsp-substitutability">substitutability</trigger> but it goes beyond substitutability; <strong>LSP implies that a subclass should not be more restrictive than the behavior specified by the superclass.</strong> As you know, Java has language support for substitutability. However, if LSP is not followed, substituting a subclass object for a superclass object can break the functionality of the code.</p>
<modal large id="modal:lsp-substitutability"><template #header>Textbook <span><span aria-hidden="true" class="glyphicon glyphicon-log-in"></span></span></template>
  <div><div><panel src="/se-book/oop/inheritance/what/unit-inElsewhere-asFlat._include_.html" popup-url="/se-book/oop/inheritance/what"><template #header><p><span class="dimmed"><span><span aria-hidden="true" class="glyphicon glyphicon-education"></span></span> Paradigms → Object Oriented Programming → Inheritance → What</span></p></template></panel></div><p></p>
<p><span class="dimmed"><strong><span>Paradigms → OOP → Inheritance →
</span></strong></span></p>
<div id="title-and-body">
<div><h4 id="substitutability"><span id="substitutability" class="anchor"></span><span>Substitutability</span><a class="fa fa-anchor" href="#substitutability" onclick="event.stopPropagation()"></a></h4></div>
<div id="main">
<div>
<p><strong>Every instance of a subclass is an instance of the superclass, but not vice-versa.</strong> As a result, inheritance allows <em>substitutability</em>: the ability to substitute a child class object where a parent class object is expected.</p>
<box>
<pic src="/se-book/67968c10181cfb0e3ad27fd3dc6425ae.png"></pic>
<p><span><span aria-hidden="true" class="fas fa-cube"></span></span> An <code class="hljs inline no-lang" v-pre>AcademicStaff</code> is an instance of a <code class="hljs inline no-lang" v-pre>Staff</code>, but a <code class="hljs inline no-lang" v-pre>Staff</code> is not necessarily an instance of an <code class="hljs inline no-lang" v-pre>AcademicStaff</code>. i.e. wherever an object of the superclass is expected, it can be substituted by an object of any of its subclasses.</p>
<p>The following code is valid because an <code class="hljs inline no-lang" v-pre>AcademicStaff</code> object is substitutable as a <code class="hljs inline no-lang" v-pre>Staff</code> object.</p>
<pre><code class="hljs java" v-pre><span>Staff staff = <span class="hljs-keyword">new</span> AcademicStaff(); <span class="hljs-comment">// OK</span>
</span></code></pre><p>But the following code is not valid <span class="dimmed">because <code class="hljs inline no-lang" v-pre>staff</code> is declared as a <code class="hljs inline no-lang" v-pre>Staff</code> type and therefore its value may or may not be of  type <code class="hljs inline no-lang" v-pre>AcademicStaff</code>, which is the type expected by variable <code class="hljs inline no-lang" v-pre>academicStaff</code>.</span></p>
<pre><code class="hljs java" v-pre><span>Staff staff;
</span><span>...
</span><span>AcademicStaff academicStaff = staff; <span class="hljs-comment">// Not OK</span>
</span></code></pre></box></div>
<div></div></div></div></div></modal>
<box>
<p><span><span aria-hidden="true" class="fas fa-cube"></span></span> Suppose the <code class="hljs inline no-lang" v-pre>Payroll</code> class depends on the <code class="hljs inline no-lang" v-pre>adjustMySalary(int percent)</code> method of the <code class="hljs inline no-lang" v-pre>Staff</code> class. Furthermore, the <code class="hljs inline no-lang" v-pre>Staff</code> class states that the <code class="hljs inline no-lang" v-pre>adjustMySalary</code> method will work for all positive percent values. Both the <code class="hljs inline no-lang" v-pre>Admin</code> and <code class="hljs inline no-lang" v-pre>Academic</code> classes override the <code class="hljs inline no-lang" v-pre>adjustMySalary</code> method.</p>
<pic src="/se-book/principles/liskovSubstitutionPrinciple/images/payroll.png" height="200"></pic>
<p></p>
<p>Now consider the following:</p>
<ul>
<li>The <code class="hljs inline no-lang" v-pre>Admin#adjustMySalary</code> method works for both negative and positive percent values.</li>
<li>The <code class="hljs inline no-lang" v-pre>Academic#adjustMySalary</code> method works for percent values <code class="hljs inline no-lang" v-pre>1..100</code> only.</li></ul>
<p>In the above scenario,</p>
<ul>
<li>The <code class="hljs inline no-lang" v-pre>Admin</code> class follows LSP because it fulfills <code class="hljs inline no-lang" v-pre>Payroll</code>’s expectation of <code class="hljs inline no-lang" v-pre>Staff</code> objects (i.e. it works for all positive values). Substituting <code class="hljs inline no-lang" v-pre>Admin</code> objects for <code class="hljs inline no-lang" v-pre>Staff</code> objects will not break the <code class="hljs inline no-lang" v-pre>Payroll</code> class functionality.</li>
<li>The <code class="hljs inline no-lang" v-pre>Academic</code> class violates LSP because it will not work for percent values over <code class="hljs inline no-lang" v-pre>100</code> as expected by the <code class="hljs inline no-lang" v-pre>Payroll</code> class. Substituting <code class="hljs inline no-lang" v-pre>Academic</code> objects for <code class="hljs inline no-lang" v-pre>Staff</code> objects can potentially break the <code class="hljs inline no-lang" v-pre>Payroll</code> class functionality.</li></ul>
<panel type="seamless"><template #header><p><span class="dimmed">Another example</span></p></template>
<p><span><span aria-hidden="true" class="fas fa-cube"></span></span> The <code class="hljs inline no-lang" v-pre>Rectangle#resize()</code> method can take any integers for <code class="hljs inline no-lang" v-pre>height</code> and <code class="hljs inline no-lang" v-pre>width</code>. This contract is violated by the subclass <code class="hljs inline no-lang" v-pre>Square#resize()</code> because it does not accept a <code class="hljs inline no-lang" v-pre>height</code> that is different from the <code class="hljs inline no-lang" v-pre>width</code>.</p>
<pic src="/se-book/principles/liskovSubstitutionPrinciple/images/rectangleSquare.png" height="120"></pic>
<p></p>
<pre><code class="hljs java" v-pre><span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> </span>{
</span><span>    ...
</span><span>    <span class="hljs-comment">/** sets the size to the given height and width*/</span>
</span><span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> height, <span class="hljs-keyword">int</span> width)</span> </span>{
</span><span>        ...
</span><span>    }
</span><span>}
</span><span>
</span><span>
</span><span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Rectangle</span> </span>{
</span><span>
</span><span>    <span class="hljs-meta">@Override</span>
</span><span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> height, <span class="hljs-keyword">int</span> width)</span> </span>{
</span><span>        <span class="hljs-keyword">if</span> (height != width) {
</span><span>            <span class="hljs-comment">//error</span>
</span><span>       }
</span><span>    }
</span><span>}
</span></code></pre><p>Now consider the following method that is written to work with the <code class="hljs inline no-lang" v-pre>Rectangle</code> class.</p>
<pre><code class="hljs java" v-pre><span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">makeSameSize</span><span class="hljs-params">(Rectangle original, Rectangle toResize)</span> </span>{
</span><span>    toResize.resize(original.getHeight(), original.getWidth());
</span><span>}
</span></code></pre><p>This code will fail if it is called as <code class="hljs inline no-lang" v-pre>makeSameSize(new Rectangle(12, 8), new Square(4, 4))</code>. That is, the <code class="hljs inline no-lang" v-pre>Square</code> class is not substitutable for the <code class="hljs inline no-lang" v-pre>Rectangle</code> class.</p></panel></box></div>
<div>
  <div><panel expandable><template #header><p><span><span aria-hidden="true" class="fas fa-dumbbell"></span></span> Exercises</p></template>
  <div><panel><template #header><p><span><span aria-hidden="true" class="glyphicon glyphicon-question-sign"></span></span><span><span aria-hidden="true" class="glyphicon glyphicon-ok-sign"></span></span> Is this LSP?</p></template>
<question>
<p>If a subclass imposes more restrictive conditions than its parent class, it violates Liskov Substitution Principle.</p>
<ul radio-group="55ada" class="radio-list">
<li class="radio-list-item"><label><input class="radio-list-input" name="55ada" type="radio"> True</label></li>
<li class="radio-list-item"><label><input class="radio-list-input" name="55ada" type="radio"> False</label></li></ul>
<template #answer><div>
<p>True.</p>
<p>Explanation: If the subclass is more restrictive than the parent class, code that worked with the parent class may not work with the child class. Hence, the substitutability does not exist and LSP is violated.</p></div></template></question></panel></div></panel></div></div></div></div></div></panel>
<panel type="seamless"><template #header><p><strong>I</strong>nterface Segregation Principle (ISP)</p></template>
  <div><div></div><p></p>
<p><span class="dimmed"><strong><span>Principles →</span></strong></span></p>
<div id="title-and-body">
<div><h4 id="interface-segregation-principle"><span id="interface-segregation-principle" class="anchor"></span><span>Interface segregation principle</span><a class="fa fa-anchor" href="#interface-segregation-principle" onclick="event.stopPropagation()"></a></h4></div>
<div id="main">
<div>
<box type="definition" seamless>
<div><p><strong>Interface segregation principle (ISP)</strong>: No client should be forced to depend on methods it does not use.</p></div></box>
<box>
<p><span><span aria-hidden="true" class="fas fa-cube"></span></span> The <code class="hljs inline no-lang" v-pre>Payroll</code> class should not depend on the <code class="hljs inline no-lang" v-pre>AdminStaff</code> class because it does not use the <code class="hljs inline no-lang" v-pre>arrangeMeeting()</code> method. Instead, it should depend on the <code class="hljs inline no-lang" v-pre>SalariedStaff</code> interface.</p>
<pre><code class="hljs java" v-pre><span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Payroll</span> </span>{
</span><span>    <span class="highlighted"><span class="hljs-comment">// violates ISP</span></span>
</span><span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">adjustSalaries</span><span class="hljs-params">(AdminStaff adminStaff)</span> </span>{
</span><span>        <span class="hljs-comment">// ...</span>
</span><span>    }
</span><span>
</span><span>}
</span></code></pre><pre><code class="hljs java" v-pre><span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Payroll</span> </span>{
</span><span>    <span class="highlighted"><span class="hljs-comment">// does not violate ISP</span></span>
</span><span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">adjustSalaries</span><span class="hljs-params">(SalariedStaff staff)</span> </span>{
</span><span>        <span class="hljs-comment">// ...</span>
</span><span>    }
</span><span>}
</span></code></pre><pic src="/se-book/principles/interfaceSegregationPrinciple/images/payroll.png" height="200"></pic>
<p></p></box></div>
<div></div></div></div></div></panel>
<panel type="seamless"><template #header><p><strong>D</strong>ependency Inversion Principle (DIP)</p></template>
  <div><div></div><p></p>
<p><span class="dimmed"><strong><span>Principles →</span></strong></span></p>
<div id="title-and-body">
<div><h4 id="dependency-inversion-principle"><span id="dependency-inversion-principle" class="anchor"></span><span>Dependency inversion principle</span><a class="fa fa-anchor" href="#dependency-inversion-principle" onclick="event.stopPropagation()"></a></h4></div>
<div id="main">
<div>
<box type="definition" seamless>
<div><p><strong>Dependency inversion principle (DIP)</strong>:</p>
<ol>
<li>High-level modules should not depend on low-level modules. Both should depend on abstractions.</li>
<li>Abstractions should not depend on details. Details should depend on abstractions.</li></ol></div></box>
<box>
<p><span><span aria-hidden="true" class="fas fa-cube"></span></span> Example:</p>
<pic src="/se-book/principles/dependencyInversionPrinciple/images/payrollEmployee.png" height="130"></pic>
<p></p>
<p>In design (a), the higher level class <code class="hljs inline no-lang" v-pre>Payroll</code> depends on the lower level class <code class="hljs inline no-lang" v-pre>Employee</code>, which is a violation of DIP. In design (b), both <code class="hljs inline no-lang" v-pre>Payroll</code> and <code class="hljs inline no-lang" v-pre>Employee</code> depend on the <code class="hljs inline no-lang" v-pre>Payee</code> interface (note that inheritance is a dependency).</p>
<p>Design (b) is more flexible (and less coupled) because now the <code class="hljs inline no-lang" v-pre>Payroll</code> class need not change when the <code class="hljs inline no-lang" v-pre>Employee</code> class changes.</p></box></div>
<div>
<div><panel expandable><template #header><p><span><span aria-hidden="true" class="fas fa-dumbbell"></span></span> Exercises</p></template>
  <div><panel><template #header><p><span><span aria-hidden="true" class="glyphicon glyphicon-question-sign"></span></span><span><span aria-hidden="true" class="glyphicon glyphicon-ok-sign"></span></span> Which of these statements is true about the Dependency Inversion Principle?</p></template>
<question>
<p>Which of these statements is true about the Dependency Inversion Principle?</p>
<ul class="contains-task-list">
<li class="task-list-item enabled"><input class="task-list-item-checkbox" type="checkbox"> a. It can complicate the design/implementation by introducing extra abstractions, but it has some benefits.</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox" type="checkbox"> b. It is often used during testing to replace dependencies with mocks.</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox" type="checkbox"> c. It reduces dependencies in a design.</li>
<li class="task-list-item enabled"><input class="task-list-item-checkbox" type="checkbox"> d. It advocates making higher level classes depend on lower level classes.</li></ul>
<template #answer><div>
<p>a</p>
<p>Explanation: Replacing dependencies with mocks is Dependency Injection, not DIP. DIP does not reduce dependencies, rather, it changes the direction of dependencies. Yes, it can introduce extra abstractions but often the benefit can outweigh the extra complications.</p></div></template></question></panel></div></panel></div></div></div></div></div></panel></div>
<div></div></div></div>