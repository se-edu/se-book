<span id="prereqs"></span>

<span id="outcomes">{{ icon_outcome }} Can explain pros and cons of software engineering</span>

<span id="title">Pros and cons</span>

<div id="body">

<box type="definition" seamless>
<include src="../../../common/definitions.md#def-se" inline trim />
</box>

The following description of the _Joys of the Programming Craft_ was taken (and emphasis added) from Chapter 1 of the famous book <trigger for="modal:mmm" trigger="click">_The Mythical Man-Month_, by Frederick P. Brooks</trigger>.

> **Why is programming fun? What delights may its practitioner expect as his reward?**
>
> **First is the sheer joy of making things.** As the child delights in his mud pie, so the adult enjoys building things,
> especially things of his own design. I think this delight must be an image of God's delight in making things,
> a delight shown in the distinctness and newness of each leaf and each snowflake.
>
> **Second is the pleasure of making things that are useful to other people.** Deep within, you want others to use your work and
> to find it helpful. In this respect the programming system is not essentially different from the child's
> first clay pencil holder "for Daddy's office."
>
> **Third is the fascination of fashioning complex puzzle-like objects of interlocking moving parts** and watching them
> work in subtle cycles, playing out the consequences of principles built in from the beginning. The programmed computer
> has all the fascination of the pinball machine or the jukebox mechanism, carried to the ultimate.
>
> **Fourth is the joy of always learning**, which springs from the nonrepeating nature of the task. In one way or another
> the problem is ever new, and its solver learns something: sometimes practical, sometimes theoretical, and sometimes both.
>
> **Finally, there is the delight of working in such a tractable medium.** The programmer, like the poet,
> works only slightly removed from pure thought-stuff. He builds his castles in the air, from air, creating by the exertion of
> the imagination. Few media of creation are so flexible, so easy to polish and rework, so readily capable of realizing grand
> conceptual structures....
>
> Yet the program construct, unlike the poet's words, is real in the sense that it moves and works, producing
> visible outputs separate from the construct itself. It prints results, draws pictures, produces sounds, moves arms.
> The magic of myth and legend has come true in our time. One types the correct incantation on a keyboard, and a display screen comes to life,
> showing things that never were nor could be.
>
> Programming then is fun because it gratifies creative longings built deep within us and delights sensibilities you have in common with all men.


> **Not all is delight, however, and knowing the inherent woes makes it easier to bear them when they appear.**
>
> **First, one must perform perfectly.** The computer resembles the magic of legend in this respect, too. If one character,
> one pause, of the incantation is not strictly in proper form, the magic doesn't work. Human beings are not accustomed to being perfect,
> and few areas of human activity demand it. Adjusting to the requirement for perfection is, I think, the most difficult part of learning to program.
>
> **Next, other people set one's objectives, provide one's resources, and furnish one's information.** One rarely controls the
> circumstances of his work, or even its goal. In management terms, one's authority is not sufficient for his responsibility.
> It seems that in all fields, however, the jobs where things get done never have formal authority commensurate with responsibility.
> In practice, actual (as opposed to formal) authority is acquired from the very momentum of accomplishment.
>
> The dependence upon others has a particular case that is especially painful for the system programmer. He depends upon other
> people's programs. These are often maldesigned, poorly implemented, incompletely delivered (no source code or test cases),
> and poorly documented. So he must spend hours studying and fixing things that in an ideal world would be complete, available, and usable.
>
> **The next woe is that designing grand concepts is fun; finding nitty little bugs is just work.** With any creative activity
> come dreary hours of tedious, painstaking labor, and programming is no exception.
>
> **Next, one finds that debugging has a linear convergence, or worse**, where one somehow expects a quadratic sort of approach to the end.
> So testing drags on and on, the last difficult bugs taking more time to find than the first.
>
> **The last woe, and sometimes the last straw, is that the product over which one has labored so long appears to be
> obsolete upon (or before) completion.** Already colleagues and competitors are in hot pursuit of new and better ideas.
> Already the displacement of one's thought-child is not only conceived, but scheduled.
>
> This always seems worse than it really is. The new and better product is generally not available when one completes his own;
> it is only talked about. It, too, will require months of development. The real tiger is never a match for the paper one,
> unless actual use is wanted. Then the virtues of reality have a satisfaction all their own.
>
> Of course the technological base on which one builds is always advancing. As soon as one freezes a design,
> it becomes obsolete in terms of its concepts. But implementation of real products demands phasing and quantizing.
> The obsolescence of an implementation must be measured against other existing implementations, not against unrealized concepts.
> The challenge and the mission are to find real solutions to real problems on actual schedules with available resources.
>
> This then is programming, both a tar pit in which many efforts have floundered and a creative activity with joys
>  and woes all its own. **For many, the joys far outweigh the woes....**

<modal header="**:book: The Mythical Man-Month: Essays on Software Engineering**" id="modal:mmm">

<table>
<tbody>
<tr>
<td>
<pic src="https://upload.wikimedia.org/wikipedia/en/f/fd/Mythical_man-month_%28book_cover%29.jpg" height="250" />
</td>
<td>
<pic src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/91/Fred_Brooks.jpg/800px-Fred_Brooks.jpg" height="250" />
</td>
<tr>
<td>

<sub>[[Text and book cover source: Wikipedia](https://en.wikipedia.org/wiki/The_Mythical_Man-Month)]</sub>

</td>
<td>

<sub>[[Fred Brooks photo source](https://commons.wikimedia.org/wiki/File:Fred_Brooks.jpg)]</sub>

</td>
</tr>
</tbody>
</table>

_The Mythical Man-Month: Essays on Software Engineering_ is a book on software engineering and project management by Fred Brooks, whose central theme is that "adding manpower to a late software project makes it later". This idea is known as Brooks's law, and is presented along with the second-system effect and advocacy of prototyping.

</modal>

</div>

<div id="extras">

<include src="exercises.md" />

</div>
